# 一 概述:
## (1)概述:
- 在linux下,库文件一般放在/usr/lib和/lib下.
- 静态库的名字一般为libxxxx.a,其中xxxx是该lib的名称.
- 动态库的名字一般为libxxxx.so.major.minor,xxxx是该lib的名称,major是主版本号, minor是副版本号.

## (2)使用:
- 当静态库和动态库重名时,gcc优先选择动态库.
- 自定义的库需复制到/usr/lib或/lib目录下,ld默认才能找到.
- gcc的-L参数指定库文件路径;-l指定文件名字.
- gcc+源文件+链接库(-L+-l),顺序不能颠倒.

## (3)静态库搜索顺序:
- ld会去找GCC命令中的参数-L
- 再找gcc的环境变量LIBRARY_PATH(gcc的环境变量).
- 再找内定目录 /lib /usr/lib /usr/local/lib 这是当初compile gcc时指定的.

## (4)动态库的搜索顺序:
- 编译目标代码时指定的动态库搜索路径(-L编译可通过但运行部通过需设置2-5任一).
- 环境变量LD_LIBRARY_PATH指定的动态库搜索路径.
- 配置文件/etc/ld.so.conf中指定的动态库搜索路径.
- 默认的动态库搜索路径/lib.
- 默认的动态库搜索路径/usr/lib.

## (5)比较:
- 静态库需要定期维护和更新,如果程序员要使用一个库的最近版本,就必须以某种方式了解该库的更新情况,然后显式地将他们的程序与更新了的库重新链接.
- 几乎每个C程序都使用标准I/O函数,如printf和scanf.在运行时,这些函数代码会被复制到每个运行进程的文本段中.在一个运行50~100个进程的典型系统上,将是对稀缺的存储器系统资源的极大浪费.
- 首先,在给定文件系统中,对于一个库只有一个.so文件,所有引用该库的可执行目标文件共享这个.so文件中的代码和数据,而不是像静态库的内容那样被拷贝和嵌入到引用它们的可执行的文件中.
- 其次,在存储器中,一个共享库的.text节的一个副本可以被不同的正在运行的进程共享.
- 当要使用静态的程序库时,连接器会找出程序所需的函数,然后将它们拷贝到执行文件,由于这种拷贝是完整的,所以一旦连接成功,静态程序库也就不再需要了.然而,对动态库而言,就不是这样.动态库会在执行程序内留下一个标记指明当程序执行时,首先必须载入这个库,所以删除动态库后执行程序会出现错误: 找不到共享库.

## (6)备注:
- LIBRARY_PATH是gcc编译时刻,是gcc的环境变量;LD_LIBRARY_PATH是程序运行时刻.
- 动态库可用来支持plugin模式开发, 例如: mysql的innodb_engine.so.

# 二 动态共享库:
## (1)种类:
- **操作系统级别的共享库和基础的系统工具库**: 这些系统库放在/lib和/usr/lib目录下.
- **应用程序级别的系统共享库** : 并非操作系统自带,但是可能被很多应用程序所共享的库,一般会被放在/usr/local/lib和/usr/local/lib64这两个目录下面.
- **应用程序独享的动态共享库** : 有很多共享库只被特定的应用程序使用,那么就没有必要加入系统库路径,以免应用程序的共享库之间发生版本冲突.因此Linux还可以通过设置环境变量LD_LIBRARY_PATH来临时指定应用程序的共享库搜索路径.可以在应用程序的启动脚本里面预先设置LD_LIBRARY_PATH,指定本应用程序附加的共享库搜索路径,从而让应用程序找到它.

# 三 静态库.

# 四 相关函数和命令:
## (1)相关函数:
- dlopen: 连接和加载动态库,在运行时要求动态连接器加载和链接任意库.
- dlclose
- dlerror
- dlsym: nginx有用.

## (2)相关命令:
- ldd: print shared library dependencies.
- ld: GNU连接器.
- pmap
