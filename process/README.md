# 一 概述：
## (1)内核态和用户态：
- 进程在生命周期内，或者执行自己的代码或者执行内核代码。内核代码是在系统调用被执行时、异常发生时或者中断到来时(中断执行程序中)执行的代码。
- 进程执行的不是内核代码，则进程正运行在用户态；如果进程执行内核代码，则进程处于内核态。
- 处理器通常使用某个控制器中的一个模式位来提供这种功能，该寄存器描述了当前进程享有的特权。当设置了模式位时，进程就运行在内核模式中。
- 内核态的进程可以执行指令集中的任何指令，并且访问系统中任何存储器的位置；用户态的进程不允许执行特权指令，比如：停止处理器、改变模式位、或者发起一个IO操作，也不允许用户态进程直接引用地址空间中内核区的代码和数据，用户程序必须通过系统调用接口间接的访问内核代码和数据。

## (2)Intel CPU保护机制分为4个特权级别：
- ring 0(kernel)：级别最高，包含系统中最重要的模块，通常是操作系统内核，通常直接与物理硬件交互，例如：CPU和Memory.
- ring 1(device driver): 驱动程序使用.
- ring 2(device driver): 驱动程序使用.
- ring 3(applications)：应用程序在该级别执行.

## (3)用户态->内核态的情况:
- 系统调用.
- 异常: CPU处理用户程序时发生了异常, 例如:缺页处理等.
- 硬件中断: 外围设备的中断.

# 二 进程和线程关系：
## (1)概述：
- 一个进程的所有信息对该进程的线程都是共享的，包括：可执行程序的代码、程序的全局内存和堆内存、栈以及文件描述符.
- 每个线程包含执行环境所必需的信息，包括：线程ID，一组寄存器值，栈(用户栈和内核栈)，调度优先级和策略、信号屏蔽字、errno变量以及线程私有数据.
- Posix Thread规范.

## (2)备注：
- 早起linux并没有支持多线程程序, 线程的系列操作都是在用户态完成; 从2.6后通过轻量级进程来支持多线程程序, 将一个轻量级进程和线程关联起来, 这样线程可以由内核单独调度.
- 相应的线程实现库有:Linux Threads(不满足Posix Thread规范, 已被NPTL取代), NPTL(Native Posix Thread Library).
- 线程共享进程的堆，同时共享进程全局的栈空间，只是每个线程独享自己的栈.
- 内核会为每个进程分配两个物理页的内核栈.

# 三 进程状态:
## (1)概述:
- 进程描述符的state字段表示当前进程的所处的状态，这些状态是互斥的，只会处于一种状态.

## (2)状态种类:
- TASK_RUNNING(可运行状态R): 进程要么在CPU上运行，要么准备运行.
- TASK_STOPPED(暂停状态T)：进程的执行被暂停，当进程接受到SIGSTOP、SIGTSTP、SIGTTIN或SIGTTOUT信号后，进入暂停状态.
- TASK_INTERRUPTIBLE(可中断的等待状态S): 进程被挂起直至某个条件变为真. 产生一个硬件中断或给进程发生信号可唤醒进程, 例如: 进程调用sleep, 等待管道, epoll等.
- TASK_UNINTERRUPTIBLE(不可中断的等待状态, 进程D(**通常是IO**))：与可中断的等待状态类似，但是把信号传递给睡眠的进程不能改变它的状态, 在特定情况下(进程必须等待，直至一个不能被中断的事件发生)很有用, 例如:进程打开一个设备文件, 其驱动程序开始探测硬件设备时会用到该状态, 探测完成前设备驱动程序不能被中断, 否则硬件设备处于不可预知状态.
- TASK_TRACED(跟踪状态): 进程的执行由debuger程序暂停.
- EXIT_ZOMBLE(僵死状态Z): 进程执行被终止，但是父进程还没有调用wait等系统调用来返回有关死亡进程的信息，调用wait前内核不会释放包含在死进程描述符中的数据.
- EXIT_DEAD(僵死撤销状态)：最终状态，父进程发出wait，因而进程由系统删除.

## (3)备注：
- 状态在文件sched.h文件定义，由两个flag表示：task->state(表示task运行状态)和task->exit_state(表示task退出状态).

# 四 多cpu架构：
## (1)SMP：
- 最早的多CPU技术，多个CPU通过一个总线访问存储器.
- 缺点：扩展性差，当存储器的接口达到饱和时，增加处理器并不能获得更高性能，支持的CPU数量有限.

## (2)MPP：
- 分布式存储模式，每个节点有自己的存储器，可以配置成SMP模式.
- 可以理解为一个SMP的横向扩展集群，MPP一般依靠软件实现.

## (3)NUMA架构：
- 每个处理器有自己的存储器，同时也可以访问别的处理器的存储器.
- CPU访问自己的存储器比访问其它CPU的存储器速度快上10-100倍，所以NUMA调优目标就是让CPU访问自己的存储器.

# 五 进程组和会话和作业
## (1)进程组:
- 表示一个和多个进程的集合.
- 功能: 用来控制信号发生, 当一个信号直接发送给进程组时, 则进程组中每个进程都会收到信号.
- 发送方式: kill -signal -n, n表示进程组号.
- 使用场景: 管道中前后进程是一个进程组.

## (2)会话(session):
- 会话是一个或多个进程组的集合, 一个进程组不允许从一个session迁移到另外的session, 线程也不能加入到其它session中的进程组.
- 会话的进程组包括: foreground进程组和backgroup进程组.
- 一个会话可以有一个控制tty(终端设备(终端登录情况下)或伪终端(网络登录情况)); 建立与控制终端连接的会话首进程称为控制进程; 一个会话中进程可分为一个前台进程组以及多个后台进程组; 若会话有控制终端, 则有一个前台进程组, 其它为后台进程组;  建立与控制终端连接的会话首进程称为控制进程; 一个会话中进程可分为一个前台进程组以及多个后台进程组; 在终端上输入字符发出的信号(ctrl+c,ctrl+\)会发给前台进程组的所有进程; 若终端端口检测到网络已断开连接, 则将挂断信号发给控制进程.
- 场景: 一个shell窗口通常就是一个session.

## (3)相关API:
- 进程组相关: setpgid,getpgid等.
- 会话相关: setsid,getsid.