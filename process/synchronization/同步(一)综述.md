# 一 同步机制:
## (1)无需同步:
- 最好的同步技术是不需要同步, 每种显式同步都有性能开销.
- 例如: 把部分内核变量声明为"每CPU变量"(per-cpu variable), 单个cpu可以随意读和修改自己的变量.

## (2)原子操作:
- CPU提供原子级别的指令操作, 例如:CAS等.

## (3)内存屏障:
- 内存屏障(memory barrier)确保, 原语之后的操作开始执行之前, 原语之前的操作都已经完成.
- 优化屏障(optimization barrier): 保证编译程序不会混淆原语之前和原语之后的汇编语言指令, 在linux中就是barrier()宏, 展开为asm volatile("":::"memory"). volatile关键字: 禁止编译器把asm中指令与其他指令重新组合. memory关键字: 强制编译器假定RAM中的所有内存单元都被汇编语言修改过, 因此编译器不能使用存放在CPU寄存器中的值来优化asm指令前的代码.

## (4)自旋锁:
- 多处理器环境中一种特殊锁, 在单处理器系统无效, 忙等.
- 在自旋锁忙等期间, 内核抢占是有效的, 等待自旋锁释放的进程可能被高优先级的进程替代.
- 读/写自旋锁: 增加内核的并发能力.

## (5)信号量:
- 实现一个加锁原语, 让等待着休眠, 直到等待的资源变为空闲.
- Linux提供两种信号量: 内核信号量(由内核控制路径使用); System V IPC信号量(用户态进程使用).

## (6)顺序锁

## (7)RCU(读-拷贝-更新)

## (8)互斥锁和条件变量

## (9)读写锁

## (10)文件锁/记录锁

# 二 RCU:
## (1)概述:
- 读-拷贝修改: 是一种以空间换时间的同步机制, 用于读性能比较重要的场景, 读者们几乎不需要同步开销, 写者间的同步开销取决于它们的同步机制.
- 可作为读写锁的一种替代, 但当写者比较多时候性能不好.
- include/rcupdate.h
- 文档: Document/RCU/*.

## (2)原理:
- 读者: 标记某块区域是RCU保护的临界区(rcu_read_lock和rcu_read_unlock之间的区域), 在退出临界区前该区域不会被回收, 完成读后通知回收器完成, 以便回收器在grace period时执行写者的update.
- 写者: 写者修改数据前首先拷贝一个被修改元素的副本, 然后在副本上修改, 待修改完成后向回收器(reclaimer)注册一个回调函数(call_rcu)以便在适当时机(grace period)执行真正的修改.

## (3)读者接口:
- rcu_read_lock: 标记某块区域为RCU read-side的临界区开始.
- rcu_read_unlock: 标记某块区域为RCU read-side的临界区结束.
- rcu_dereference

## (4)写者接口:
- synchronize_rcu: 阻塞直至所有**已存在**的RCU read-side临界区读者完成; 或者不block,向reclaimer注册一个callback函数, 当RCU read-side临界区完成后执行, 该callback通常称为call_rcu.
- rcu_assign_pointer

# 三 文件锁