# 一 概述:
## (1)概述:
- 当中断发送时, 并不是所有操作都很紧迫, 因此把所有操作放在中断处理程序中是不合适的, 因此可能中断处理分为两部分: 上半部(top half)和下半部(bottom half).
- 上半部: 上半部通过中断处理程序实现, 接收到一个中断, 立即开始执行, 但只做严格时限工作, 例如对接收到的中断进行应答或硬件复位, 上半部是在所有中断被禁止的情况下完成的(最坏情况下), 最好情况是同类型中断被屏蔽, 应该尽可能减少中断处理程序的工作内容.
- 下半部: 可通过多种机制实现: BH和任务队列(已过时), 软中断(softirqs)和tasklet(通过软中断实现), 工作队列(work queue).
- Linux 2.6后三种下版本实现选择: 软中断, tasklet和工作队列, tasklet类似软中断, 工作队列机制则完全不同, 它是通过内核线程实现.
- 中断的处理依赖中断的类型.

## (2)常用中断类型:
- I/O中断
- 时钟中断
- 处理器间中断

# 二 中断处理程序:
## (1)概述:
- 在响应一个特定中断时内核会执行一个函数, 即中断处理程序(interrupt handler)/中断服务例程(interrupt service routine).
- 产生中断的设备的驱动程序提供中断处理程序, 若一个设备可以产生多个中断, 则需提供对于多个处理程序.
- 中断处理程序与其它内核函数区别: 中断处理程序是被内核调用来响应中断的, 运行于中断上下文中.

## (2)注册和释放中断处理程序:
- 驱动程序通过**request_irq**函数来注册和激活一个中断处理程序, 以便处理中断.
- 卸载驱动程序时, 需注销相应的中断处理程序, 并释放中断线(free_irq).

## (3)编写中断处理程序:
- 声明格式: static irqreturn_t intr_handler(int irq, void *dev_id, pt_reqs *reqs)

## (4)备注:
- 中断程序无需是可重入的, 因为当一个给定的中断程序在执行时, 相应中断线在所有处理器上都会被屏蔽掉.
