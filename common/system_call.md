# 一 概述：
## (1)介绍：
- 系统调用在用户进程和硬件设备之间增添了一个中间层，为用户空间提供硬件的抽象接口，保证了系统的稳定性和安全.
- 用户访问内核的方法：系统调用、异常等.
- linux中，每个系统调用都有一个系统调用号，这个唯一的调用号可以关联到系统系统调用，内核用**sys_call_table**记录了已注册的系统调用列表.

## (2)执行原理：
- 应用程序通过软中断来通知内核执行系统调用，通过引发一个异常促使系统切换到内核态去执行异常处理程序(128号异常处理程序)，此处就是系统调用处理程序。
- 用户空间通过系统调用号放入eax寄存器来告诉系统调用处理程序调用哪个系统调用.
- **调用参数**是通过寄存器来传递的，在x86中，ebx, ecx, edx, esi和edi用来存放前五个参数. 发出系统调用之前, 系统调用参数被写入CPU寄存器, 在调用系统调用服务例程之前, 内核再把CPU寄存器中的参数拷贝到内核堆栈.

## (3)相关API和文件：
- syscall：直接调用系统调用(sys_xxx()).
- syscalls：查询所有系统调用.
- 系统调用号：/usr/include/asm/unistd.h.
- include/linux/syscalls.h: 通过SYSCALL_DEFINE来查看系统调用的实现.

## (4)包装函数(wrapper函数)：
- 系统调用(sys_xxx)通常不被直接调用，而是通过它的包装函数xxx来调用，man 2 xxx显示的是包装函数.
- 通常，包装函数干的事不多，在调用系统调用之前，把参数拷贝到指定寄存器；在调用之后跟进系统调用的返回值设置errno变量.
- 注意：系统调用返回一个负值给调用者，然后由包装函数来设置errno变量，包装函数返回-1给包装函数的调用者.

## (5)相关命令：
- strace：跟踪某个命令的系统调用.

# 二 参数和结果传递:
## (1)参数传递:
- **调用参数**是通过寄存器来传递的，在x86中，ebx, ecx, edx, esi和edi用来存放前五个参数. 发出系统调用之前, 系统调用参数被写入CPU寄存器, 在调用系统调用服务例程之前, 内核再把CPU寄存器中的参数拷贝到内核堆栈.
- **使用寄存器传递参数的条件**: 参数个数不能超过6个, 因为寄存器的数量有限; 参数长度不能超过寄存器的长度.

## (2)结果传递:
- 系统调用结束需从内核态切回到用户态. 当系统调用例程结束(return语句把返回值放在内核栈, 该值被复制到寄存器eax), 标准库会处理该寄存器并把返回值传递给应用程序.

## (3)内核访问用户空间的情况:
- 系统调用参数超过6个参数时, 用一个单独的寄存器指向进程地址空间中这些参数值所在的一个内存区来实现参数传递.
- 系统调用产生大量数据, 不能通过返回值机制来传递给用户进程, 必须通过指定内存区交换数据, 该内存区必须在用户空间, 从而用户程序能够访问.