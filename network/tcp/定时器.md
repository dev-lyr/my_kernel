# 一 TCP定时器:
## (1)概述:
- 代码: net/ipv4/tcp_timer.c

# 二 重传定时器(retransmit_timer):
## (1)功能:
- 发送方超过了一段时间仍然没有收到确认, 就认为刚才发送的分组丢失了，因而重传前面发送过的分组，即超时重传.
- 要实现超时重传, 就要在每发送完一个分组设置一个超时计时器即重传定时器.
- 注意超时重传时间的选择.

## (2)RTO(retransmission timeout):
- TCP_RTO_MIN: 0.2HZ即200ms, 重传的下限, 不可配置, 即使RTT再小也无用.
- TCP_RTO_MAX: 120 HZ即120s.

## (3)相关系统配置:
- tcp_retries1:默认3, 在已建立的连接上, tcp在不调用网络层的情况下尝试重传连接的次数, 一旦超过该连接, 就会首先当用网络层更新路由, 然后再重传.
- tcp_retries2:默认15, 在已建立的连接上, tcp包的尝试次数, 超过则丢弃该包.
- tcp_syn_retries: 默认6, 不高于127, 内核主动的新建连接发送syn包的尝试次数.
- tcp_synack_retries: 默认5, 不高于255, 内核在被动的连接中, 尝试发送syn ack的次数.

# 三 零窗口探测计时器(probe_timer):
## (1)功能:
- 例如：B向A发送了零窗口报文不久后, B的接受缓存又有了一些存储空间.于是B向A发送其B的接受窗口为400的报文段，然而这个报文段丢失了.A一直等待收到B发送的非零窗口的通知，而B也一直等待A发送的数据.如果没有其他措施，这种互相等待的死锁局面将一直延续下去.
- 为了解决这个问题, TCP为每一个连接设有一个持续计时器.只要TCP的一方受到对方的零窗口通知，就启动持续计时器.若持续计时器设置的时间到期，就发送一个零窗口探测报文段(仅携带1个字节数据)，而对方就在确认这个探测报文段时给出现在的窗口值.如果窗口值任然为零，那么受到这个报文段的一方就重新设置持续计时器.如果窗口不是零，那么僵局就打破了.
- TCP从不放弃发送窗口探测, 这些探测经过每隔60秒发送一次，这个过程持续到窗口被打开或应用进程使用的连接被终止.

# 四 保活(keepalive)计时器:
## (1)功能:
- 可检测一个空闲连接的另一端何时崩溃或重启.
- 例如：客户已主动与服务器建立了TCP连接, 但后来客户主机突然出故障.显然，服务器以后就再收不到客户发来的数据.因此，需要措施使服务器不要再白白等下去.这时就需要保活计时器.通常服务器设置这个功能.
- 服务器每收到一次客户的数据, 就重新设置保活计时器，时间的设置通常是两个小时.若两个小时内没有收到客户的数据，服务器就发送一个探测报文段，以后则每隔75s发送一次.若一连发送10个探测报文段后仍无客户的相应，服务器就认为客户端出现了故障，接着就关闭这个连接.

## (2)相关socket选项(man tcp): 
- TCP_KEEPIDLE
- TCP_KEEPCNT
- TCP_KEEPINTVL.

## (3)相关系统变量:
- tcp_keepalive_time: 默认为2小时, 当keepalive开启时, 等待2小时后发送keepalive probe消息.
- tcp_keepalive_probes: 默认为9, 表示决定关闭连接前需发送多少keepalive探测包.
- tcp_keepalive_intvl: 每个keepalive探测包发出的间隔时间, 默认为75s.

# 五 2MSL定时器:
## (1)功能:
- 测量一个连接处于TIME_WAIT状态的时间.
- 在TCP连接释放时, 主动关闭的一端进入TIME-WAIT状态后连接才会释放掉.2MSL定时器设置TIME_WAIT状态的时间为2MSL.详细见TCP连接的管理.

# 六 延迟确认定时器(delack_timer):
## (1)功能:
- 接收方延迟发送ACK给发送端, 直至有数据返回给发送端或者定时器时间到.

## (2)相关socket选项:
- TCP_QUICKACK: 开启快速确认模式, ack被快速发送.