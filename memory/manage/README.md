# 一 用户内存分配(虚拟地址):
## (1)概述:
- 详细参见进程的地址空间.
- 内核认为用户态进程的动态内存分配是不紧迫, 因此总是尽量推迟给用户态进程分配内存.
- 对用户态进程是不信任, 因此内核必须随时准备捕获用户态进程引起的所有寻址错误.
- 当用户态进程请求动态内存时, 并没有获得请求的页框, 仅仅是获得对一个新的线性地址区间的使用权,缺页异常处理程序在当进程访问该地址时真正给进程分配页框.

## (2)字节为单位分配和释放(用户空间内存):
- malloc, calloc,realloc和free.
- brk(malloc调用):系统调用.
- sbrk:c库封装函数.
- 备注: brk与其他函数不同, 它是系统调用, 其他函数都是使用brk和mmap系统调用使用的C语言库函数.
- 备注: 避免使用brk和sbrk, malloc的移植性和可用性更好.

# 二 内核内存分配:
## (1)概述:
- 内核是os中优先级最高的部分,若某个内核函数请求内存, 那么必定是有正当理由, 因此需立即分配.
- 内核信任自己, 所有内核函数都被假定是没有错误, 因此内核函数没有对编程错误的保护.

## (2)分配和释放页框(以页为单位, linux/gfp.h):
- alloc_pages: 分配几个连续的物理页(物理上连续), 并返回一个page结构指针指向第一个页.
- alloc_page: 分配单个物理页.
- page_address: 返回给物理页当前所在环境的逻辑地址.

## (3)字节为单位分配和释放(内核内存):
- kmalloc/kfree: 获得/释放以字节为单位的一块内核内存, 在物理上是连续的.
- vmalloc/vfree: 与kmalloc类似, 只不过vmalloc是虚拟地址是连续的, 物理地址无需连续, 非连续物理内存, 类似用户空间函数的工作方式.
- 备注: 很多内核代码直接使用kmalloc, 因为kmalloc的性能比vmalloc好.

## (4)相关系统:
- **伙伴系统**: 一种健壮、高效的分配策略,用来解决**外部碎片**问题,以**页框**为分配单元, 适合大内存需求.
- **slab算法**: 用来解决**内部碎片**问题, 以**字节**为分配单元.
