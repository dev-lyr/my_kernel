# 一 概述:
## (1)概述:
- 进程地址空间(address area): 允许进程使用的的全部线性地址空间，每个进程有一个32或64位的连续的地址空间，空间大小取决于体系结构.
- 两个进程的地址空间没有任何关系,除非选择共享地址空间,例如线程.
- 虚拟内存区域(VMA): 内核通过内存区域来表示线性地址空间,内存区域由起始地址、长度和访问权限来描述.
- 进程地址空间内的任何有效地址都只能位于唯一的VMA,这些VMA不能相互覆盖.

## (2)进程线性地址(linear address)空间划分(x86 32位为例):
- 0x00000000~0xbfffffff: 进程运行在用户态和内核态都可以寻址.
- 0xc0000000~0xffffffff: 只有内核态可以寻址.
- 备注: 当进程运行在用户态, 产生的线性地址小于0xc0000000; 当进程运行在内核态时, 执行内核代码, 产生的地址大于或等于0xc0000000, 但某些情况下, 内核为了检索或存放数据必须访问用户态线性地址空间.
- 宏PAGE_OFFSET的值时0xc0000000, 表示内核线性空间的开始处; 64位时是0xffff880000000000.
- X86_64结构中虚拟地址空间使用48位(即2的48次方,256TB), 一半用户空间和一半内核空间.

## (3)虚拟地址空间布局(vma):
- 可执行文件代码的内存映射，即代码段(text section).
- 可执行文件的已初始化全局变量的内存映射，即数据段(data section).
- 未初始化全局变量,bss段.
- 进程用户空间栈(非进程内核栈).
- 任何共享内存段.
- 任何内存映射文件.
- 任何匿名的内存映射(堆)，例如malloc分配的内存.

## (4)备注:
- 每个进程有两个物理页大小的内核栈.
- 内核线程没有虚拟地址空间, 也没有内存描述符.

# 二 内存描述符(mm_struct).
## (1)概述:
- 内核使用内存描述符结构体来表示进程的地址空间,该结构包含和进程地址空间相关的全部信息.
- 内存描述符由mm_struct结构体表示,定义在sched.h文件中.

## (2)mm_struct结构体:
- struct vm_area_struct * mmap: 指向VMA对象的链表头.
- struct rb_root mm_rb: 指向VMA对象红-黑树的根.
- unsigned long start_code, end_code: 可执行代码的起始/结束地址.
- unsigned long start_data,end_data: 已初始化数据的起始/结束地址.
- unsigned long start_brk, brk: 堆的起始/结束地址.
- unsigned long start_stack: 用户态进程栈的起始地址.
- 等等.

## (3)内核线程的内存描述符:
- 内核线程仅运行在内核态, 永远不会访问低于TASK_SIZE(等于PAGE_OFFSET).

## (4)备注:
- task_struct的mm和active_mm属性.

# 三 虚拟内存区域(VMA):
## (1)概述:
- 虚拟内存区域由vm_area_struct结构体描述，定义在文件mm_types.h中, 也称为虚拟内存区域或**VMA**.
- VMA描述了指定地址空间内连续区间上的一个独立内存范围.
- 内核将每个VMA作为一个单独的内存对象管理，每个内存区域也有一致的属性，例如访问权限等.

## (2)vm_area_struct:
- vm_mm: 指向该VMA所属的mm_struct实例.
- vm_start,vm_end: 该VMA的起始和结束地址.
- vm_ops: 指向各种方法, 用于在该VMA上执行各种标准操作.
- vm_next
- vm_rb
- vm_file
- 等等.

## (3)备注:
- cat /proc/pid/maps: 查询进程的虚拟内存区域.
- pmap命令

# 四 堆的管理:
## (1)概述:
- 每个进程有一个特殊内存区域,即堆(heap),堆用于满足进程的动态内存请求.
- 内存描述符的start_brk和brk分别表示堆的开始地址和结束地址.

## (2)相关API:
- malloc, calloc,realloc和free.
- brk(malloc调用):系统调用.
- sbrk:c库封装函数.
- 备注:brk与其他函数不同,它是系统调用,其他函数都是使用brk和mmap系统调用使用的C语言库函数.
